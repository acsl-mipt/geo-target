namespace ru.mipt.acsl

"Строка"
type string [u8]

"Пара номер компонента и его уникальный идентификатор"
type component_number_guid_pair
struct
(
  'Номер компонента в пределах устройства'
  ber  number,
  'Уникальный идентификатор компонента'
  guid guid,
)

"Идентификатор устройства и его корневого компонента"
type short_id
struct
(
  'Уникальный идентификатор устройства'
  guid  deviceGuid,
  'Уникальный идентификатор компонента устройства'
  guid  rootComponentGuid,
)

"Идентификатор устройства и всех его компонентов"
type full_id struct
(
    short_id shortId,
    'Идентификаторы всех компонентов устройства'
    [component_number_guid_pair, 1..*] deviceComponentGuidPairs,
)

'Компонент идентификации устройства и всех его компонентов'
component Identification:0
{
  parameters
  (
    full_id fullId,
  )

  'Запросить идентификатор устройства и идентификатор компонента устройства'
  command requestShortId() -> short_id

  'Запросить идентификатор устройства, компонента устройства и всех его подкомпонентов'
  command requestFullId() -> full_id

  'Запросить идентификатор компонента по номеру'
  command requestComponentGuid(ber componentNumber) -> guid
}

"Ошибка начала режима сегментированной выдачи"
type segment_start_ack_error enum ber (ALREADY_STARTED = 1, INVALID_STATE = 2)

"Ошибка останова режима сегментированной выдачи"
type segment_stop_ack_error enum ber (NOT_STARTED = 1, INVALID_STATE = 2)

"Ошибка обработки получения сегмента"
type segment_process_ack_error enum ber (INVALID_STATE = 1)

"Компонент режима сегментированной передачи ТМ-сообщения"
component Segment
{
  parameters
  (
    'Режим гарантированной доставки активен'
    b8  isSegmentationAckModeActive,
    'Максимальный номер сегмента'
    ber maxSegmentNumber,
    'Режим подтверждения получения каждого сегмента активен'
    b8  isAckOnEverySegmentModeActive,
  )

  'Начать режим гарантированной передачи'
  command startSegmentAckMode:0() -> segment_start_ack_errror?

  'Отключить режим гарантированной передачи'
  command stopSegmentAckMode:1() -> segment_stop_ack_error?

  'Запросить статус режима гарантированной передачи'
  command requestAckModeStatus:2() -> b8

  'Обработать статус режима гарантированной передачи'
  command processAckModeStatus:3(b8 isSegmentationAckModeActive) -> segment_process_ack_error?

  'Включить режим подтверждения получения каждого сегмента'
  command startAckOnEverySegmentMode:4() -> segment_start_ack_errror?

  'Выключить режим подтверждения получения каждого сегмента'
  command stopAckOnEverySegmentMode:5() -> segment_stop_ack_error?
}

"Компонент сервера поддерживающиего сегментированную передачу ТМ-сообщения"
component SegmentSender with Segment
{
  'Обработать подтверждения о получении сегментов'
  command processSegmentsAck:0([ber, 1..*] segmentsReceived) -> segment_process_ack_error?
}

"Компонент клиента поддерживающего сегментированное получение ТМ-сообщения"
component SegmentReceiver with Segment
{
  parameters
  (
    'Перечень полученных сегментов'
    [ber] segmentsReceived,
  )

  'Перечень полученных сегментов'
  status segmentsReceived
  (
    segmentsReceived,
  )

  'Запросить перечень полученных сегментов'
  command requestSegmentsAck() -> [ber]
}

/* Tm */

'Циклический массив'
type ring_buf struct
(
  'Данные циклического массива'
  [u8] data,
  'Смещение начала цкилического массива'
  ber startOffset,
  'Смещение конца циклического массива'
  ber endOffset,
)

'Номер компонента и номер сообщения'
type comp_msg struct
(
  'Номер компонента'
  ber componentNum,
  'Номер сообщения в компоненте'
  ber messageNum,
)

'Информация о событии'
type event_info struct
(
  comp_msg componentMessage,
  'Номер события'
  ber      eventNum,
)

type tm_cmd_error enum ber (INVALID_ARGUMENT = 1, INVALID_STATE = 2)

'Управление формированием и выдачей ТМ-информации'
component Tm
{
  parameters
  (
    'Заявки на однократную выдачу событийных ТМ-сообщений'
    [u8]         onceRequests,
    'Запреты на формирование и выдачу сообщений'
    [[u8]]       deniedMessagesByComponent,
    'Заявки на выдачу событийных ТМ-сообщений в соответствии с частотой выдачи'
    [[u8]]       priorityOrderedRequests,
    'Массив внеочередной выдачи ТМ-сообщений'
    ring_buf     outOfOrderMesages,
    'Массив утерянных событий'
    [event_info] lostEvents,
  )

  'Выдать событийное ТМ-сообщение'
  command sendEventMessage('Информация о событии' event_info eventInfo) -> tm_cmd_error?

  'Выдать статусное сообщение во внеочередную выдачу'
  command sendStatusMessage(comp_msg componentMessage) -> tm_cmd_error?

  'Установить запрос на выдачу в соответствии с приоритетом'
  command setMessageRequest(comp_msg componentMessage, 'Приоритет' ber priority) -> tm_cmd_error?

  'Снять запрос на выдачу в соответствии с приоритетом'
  command clearMessageRequest(comp_msg componentMessage, 'Приоритет' ber priority) -> tm_cmd_error?

  'Запретить формирование ТМ-сообщения'
  command denyMessage(comp_msg componentMessage) -> tm_cmd_error?

  'Снять запрет на формирование ТМ-сообщения'
  command allowMessage(comp_msg componentMessage) -> tm_cmd_error?

  'Установить запрет на формирование и выдачу события'
  command denyEvent(event_info eventInfo) -> tm_cmd_error?

  'Снять запрет на формирование и выдачу события'
  command allowEvent(event_info eventInfo) -> tm_cmd_error?
}

/* Scripts */

'Идентификатор скрипта'
type script_id guid

'Информация о скрипте'
type script_info struct
(
  script_id scriptId,
  'Данные скрипта'
  [u8]      scriptData,
  'Байткод скрипта'
  [u8]      scriptCode,
)

'Дата и время'
type date_time ber
'Период времени'
type period    ber

'Запланированный запуск скрипта'
type script_run_timing struct
(
  'Идентификатор запланированного запуска'
  guid        id,
  'Запуск запланирован'
  b8          isActive,
  script_id   scriptId,
  'Время запуска'
  date_time   runOn,
  'Периодический скрипт'
  b8          isRepeated,
  'Период повторения'
  period /s/  repeatPeriod,
  'Повторение ограничено'
  b8          isRepeatingLimitedByDate,
  'Дата и время окончания повторения запусков скрипта'
  date_time   repeatUntil,
)

type scripting_error enum ber (INVALID_ARGUMENT = 1, INVALID_STATE = 2)

'Управление бортовыми скриптами (циклограммами)'
component Scripting
{
  parameters
  (
    'Идентификаторы бортовых скриптов'
    [guid]              scriptsIds,
    'Бортовые скрипты'
    [script_info]       scripts,
    'Данные планировщика запуска скриптов'
    [script_run_timing] scriptsRunTimings,
  )

  'Загрузить скрипт'
  command uploadScript
  (
    script_id scriptId,
    [u8]      scriptData,
    [u8]      scriptCode,
  ) -> scripting_error?

  'Удалить скрипт'
  command deleteScript(script_id scriptId) -> scripting_error?

  'Запустить скрипт незамедлительно'
  command runScriptNow(script_id scriptId) -> scripting_error?

  'Запланировать запуск скрипта'
  command scheduleScriptRun(script_run_timing scriptRunTiming) -> scripting_error?

  'Активировать запланированный запуск скрипта'
  command enableScriptRunTiming(guid scriptRunTimingId) -> scripting_error?

  'Деактивировать запланированный запуск скрипта'
  command disableScriptRunTiming(guid scriptRunTimingId) -> scripting_error?

  'Перечень загруженных скриптов'
  status availableScriptsIds
  (
    scriptsIds,
  )

  'Данные планировщика запуска скриптов'
  status scriptsRunTimings
  (
    scriptsRunTimings,
  )
}

/* Files */
'Информация о файле'
type full_file_info struct
(
  'Путь до файла'
  string filePath,
  'Аттрибуты файла'
  ber    fileAttrs,
  'Данные файла'
  [u8]   fileContents,
)

type node_info struct
(
  'Имя узла в пределах каталога'
  string name,
  'Флаг каталога'
  b8     isDir,
  'Аттрибуты узла'
  ber    attrs,
)

type file_upload_error enum ber (ALREADY_EXISTS = 1, CANT_WRITE = 2)
type file_delete_error enum ber (NOT_FOUND = 1, CANT_DELETE = 2)
type file_download_error enum ber (NOT_FOUND = 1, CANT_READ = 2, NOT_FILE = 3)
type file_list_error enum ber (NOT_FOUND = 1, CANT_READ = 2, NOT_DIR = 3)
type file_create_dir_error enum ber (NOT_FOUND = 1, CANT_WRITE = 2)

"Компонент поддерживающий управление файловой системой"
component Files
{
  'Загрузить файл'
  command uploadFile('Информация о загружаемом файле' full_file_info fileInfo) -> file_upload_error?

  'Скачать файл'
  command downloadFile('Путь до файла' string path) -> or<full_file_info, file_download_error>

  'Удалить файл или каталог'
  command deleteNode('Путь до узла' string path) -> file_delete_error?

  'Запросить перечень файлов в каталоге'
  command requestFileList('Путь до каталога' string path) -> or<[node_info], file_list_error>

  'Запросить создание каталога'
  command createDir('Путь к каталогу' string path) -> file_create_dir_error?
}

"Адрес абонента"
type address ber

"Запись таблицы маршрутизации"
type route struct
(
  "Адрес назначения"
  address destination_address,
  "Следующий узел в пути"
  address next_hop,
)

/* Router, dynamic routing table */

"Компонент реализующий возможность динамической маршрутизации и управления таблицей маршрутизации с НКУ"
component Router
{
  parameters
  (
    "Таблица маршрутизации по устройствам"
    [route] routes,
    "Таблица маршрутизации по группам"
    [route] groupRoutes,
  )

  "Установить правило маршрутизации для абонента"
  command setRoute("Адрес абонента" address address, "Следующий узел в пути" address next_hop)

  "Удалить все правила для абонента"
  command delRoute("Адрес абонента" address address)

  "Установить правило маршрутизации для абонента"
  command setGroupRoute("Адрес группы" address groupAddress, "Следующий узел в пути" address next_hop)

  "Удалить все правила для группы"
  command delGroupRoute("Адрес группы" address groupAddress)
}